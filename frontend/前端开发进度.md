# ResVizCopilot 2.0 前端开发进度

## 项目概述
基于Vue 3 + Element Plus + Mind-elixir的科研智能体前端界面，实现研究树可视化、智能体对话和工程管理三大核心功能。

## 开发阶段规划

### 阶段一：基础框架搭建与技术验证 ✅
> **目标**：验证技术可行性，搭建基础开发环境，实现最小可用原型
> **预期效果**：能够运行基础Vue应用，验证Mind-elixir集成可行性
> **状态**：已完成 - Vue 3应用已成功运行在 http://localhost:8080

- [x] **1.1 项目初始化与环境配置**
  - [x] 清理现有src目录，重新初始化Vue 3项目结构

  - [x] 安装并配置核心依赖：Vue 3、Pinia、Element Plus、Mind-elixir

  - [x] 配置开发环境的API代理，连接后端服务

- [x] **1.2 Mind-elixir技术验证**
  - [x] 创建简单的Mind-elixir包装组件
  - [x] 验证Mind-elixir的基础渲染功能
  - [x] 测试只读模式配置，确保禁用所有编辑功能
  - [x] 验证节点样式自定义能力（style、tags、icons属性）
  - [x] 测试数据格式转换的可行性

- [x] **1.3 基础UI框架**
  - [x] 创建应用根组件App.vue，实现三栏布局结构
  - [x] 创建基础的头部导航组件
  - [x] 实现响应式布局框架（桌面/平板/移动端适配）
  - [x] 配置Element Plus主题和全局样式
  - [x] 创建基础的加载和错误提示组件
  - [x] 创建Pinia状态管理stores (projectStore, treeStore, messageStore, uiStore)
  - [x] 创建API服务层 (apiService.js)
  - [x] 创建基础组件框架 (AppHeader, ProjectManager, ResearchTree, MessageCenter)

### 阶段二：数据转换与研究树可视化 ✅
> **目标**：实现后端数据到Mind-elixir的转换，完成研究树的基础展示
> **预期效果**：能够正确显示后端研究树数据，节点样式区分清晰
> **状态**：✅ 已完成 - 数据转换系统实现，现代化视觉设计完成，支持后端数据获取测试

- [x] **2.1 Mind-elixir技术验证** ✅
  - [x] 解决Mind-elixir版本兼容性问题（降级到4.5.2版本）
  - [x] 实现样式隔离，避免全局CSS污染Mind-elixir原生样式
  - [x] 创建符合Mind-elixir规范的测试数据
  - [x] 验证Mind-elixir的基础渲染功能和交互能力
  - [x] 实现只读模式配置，确保数据安全

- [x] **2.2 研究树组件开发** ✅
  - [x] 创建MindElixirWrapper组件，封装Mind-elixir实例
  - [x] 实现完整的只读模式Mind-elixir配置
  - [x] 实现节点选择事件处理和状态管理
  - [x] 集成到ResearchTree.vue主组件
  - [x] 解决主题配置和背景颜色问题
  - [x] 修复响应式布局和panel-header高度问题

- [x] **2.3 数据转换系统** ✅
  - [x] 实现ResearchTreeTransformer类，处理后端快照数据转换
  - [x] 实现节点样式配置系统（问题节点、解决方案节点的颜色区分）
  - [x] 实现状态指示器（进行中、成功、失败、选中等状态的图标显示）
  - [x] 处理特殊标识（智能体操作中、快照查看等临时状态）
  - [x] 创建空数据和错误数据的处理逻辑
  - [x] 采用现代化配色方案，基于Design System原则
  - [x] 实现分层样式控制系统，支持动态CSS类应用

- [x] **2.4 API集成基础** ✅
  - [x] API服务层已存在，支持后端接口调用
  - [x] 实现获取当前快照数据的接口调用
  - [x] 基础的数据流已经建立
  - [x] 扩展API服务，添加研究树和工程管理相关接口
  - [x] 测试后端真实数据的转换流程（包含模拟数据测试）
  - [x] 验证不同类型节点的正确显示

### 阶段三：状态管理与工程管理 ✅
> **目标**：实现Pinia状态管理，完成工程的创建、保存、加载功能
> **预期效果**：能够管理多个工程，支持工程切换和数据持久化
> **状态**：✅ 已完成 - 所有工程管理功能已实现，状态管理完善

- [x] **3.1 Pinia状态管理** ✅
  - [x] 创建projectStore，管理当前工程和工程列表 ✅
  - [x] 创建treeStore，管理研究树数据和选中状态 ✅
  - [x] 创建messageStore，管理消息列表和智能体状态 ✅
  - [x] 创建uiStore，管理界面状态和主题设置 ✅
  - [x] 实现状态持久化（localStorage） ✅
  - [x] 创建状态锁管理器，处理操作互斥 ✅

- [x] **3.2 工程管理组件** ✅
  - [x] 创建ProjectManager主组件 ✅
  - [x] 创建AppHeader组件，显示当前工程信息和操作按钮 ✅
  - [x] 实现工程列表和操作功能（ProjectManager包含列表功能） ✅
  - [x] 创建工程对话框，处理工程创建和另存为 ✅
  - [x] 实现工程的创建、保存、加载、删除功能 ✅

- [x] **3.3 工程管理API集成** ✅
  - [x] 实现工程管理相关的API调用 ✅
  - [x] 处理工程操作的错误和加载状态 ✅
  - [x] 实现工程切换时的数据同步 ✅
  - [x] 添加操作确认对话框和用户反馈 ✅

### 阶段四：消息系统与智能体对话 ✅
> **目标**：实现消息列表展示和智能体交互功能
> **预期效果**：能够显示消息历史，支持智能体选择和消息发送
> **状态**：✅ 已完成 - 完整的消息系统和智能体对话功能已实现

- [x] **4.1 消息展示组件** ✅
  - [x] 创建MessageCenter主组件 ✅
  - [x] 创建MessageList组件，支持虚拟滚动优化 ✅
  - [x] 创建MessageItem组件，支持三层结构（标题→内容→思考） ✅
  - [x] 创建MarkdownRenderer组件，渲染消息内容 ✅
  - [x] 实现消息的折叠展开功能 ✅

- [x] **4.2 智能体交互组件** ✅
  - [x] 创建AgentSelector组件，智能体选择下拉框 ✅
  - [x] 创建NodeSelector组件，根据智能体类型动态显示可选节点 ✅
  - [x] 创建ChatInput组件，多行文本输入和发送功能 ✅
  - [x] 实现智能体配置和节点过滤逻辑 ✅
  - [x] 添加输入验证和错误提示 ✅

- [x] **4.3 消息状态管理** ✅
  - [x] 创建messageStore，管理消息列表和状态 ✅
  - [x] 实现消息的增删改查操作 ✅
  - [x] 处理消息的生成状态（generating、completed、failed） ✅
  - [x] 实现消息操作（查看快照、回溯消息、复制内容） ✅

### 阶段五：SSE流式数据与实时交互 ✅
> **目标**：实现SSE流式数据接收，支持实时消息更新和智能体交互
> **预期效果**：智能体对话流畅，支持实时数据流和断连重连
> **状态**：✅ 已完成 - 完整的SSE流式传输和实时交互功能已实现

- [x] **5.1 SSE服务开发** ✅
  - [x] 创建SSEService类，管理EventSource连接 ✅
  - [x] 实现自动重连机制和错误处理 ✅
  - [x] 实现patch数据的解析和应用 ✅
  - [x] 处理连接状态的UI反馈 ✅
  - [x] 实现连接断开时的优雅降级 ✅

- [x] **5.2 流式数据处理** ✅
  - [x] 实现消息的实时更新机制 ✅
  - [x] 处理思考过程的流式显示 ✅
  - [x] 实现智能体操作状态的实时反馈 ✅
  - [x] 处理数据库操作结果的同步 ✅
  - [x] 实现停止生成功能 ✅

- [x] **5.3 智能体调用集成** ✅
  - [x] 集成智能体消息发送API ✅
  - [x] 实现智能体工作状态的界面锁定 ✅
  - [x] 处理智能体错误和超时情况 ✅
  - [x] 实现消息回溯功能 ✅
  - [x] 添加操作进度指示和用户反馈 ✅

### 阶段六：快照功能与历史查看 📸
> **目标**：实现快照的临时查看功能，支持历史状态回溯
> **预期效果**：能够查看任意历史快照，支持快照间的切换和对比

- [ ] **6.1 快照查看功能**
  - [x] 实现快照的临时显示机制（treeStore.viewSnapshot/exitSnapshotView）
  - [x] 创建快照查看的UI提示和控制（中心面板顶部提示与返回按钮）
  - [x] 实现快照主题的切换（查看模式降低明度与饱和度）
  - [x] 处理快照查看状态的进入和退出（displaySnapshotData 数据流）
  - [ ] 实现快照数据的缓存机制

- [ ] **6.2 快照控制组件**
  - [ ] 创建SnapshotControls组件
  - [ ] 实现快照查看的触发按钮
  - [ ] 添加"正在查看历史快照"的状态提示
  - [ ] 实现返回当前状态的功能
  - [ ] 处理快照查看时的操作限制

### 阶段七：用户体验优化与完善 ✨
> **目标**：优化用户体验，完善错误处理，提升应用的稳定性和易用性
> **预期效果**：应用运行稳定，用户操作流畅，错误处理完善

- [ ] **7.1 性能优化**
  - [ ] 实现组件懒加载和代码分割
  - [ ] 优化大数据量的渲染性能
  - [ ] 实现防抖和节流优化
  - [ ] 添加缓存策略减少API调用
  - [ ] 优化Mind-elixir的渲染性能

- [ ] **7.2 错误处理与用户反馈**
  - [ ] 完善全局错误处理机制
  - [ ] 实现友好的错误提示和恢复建议
  - [ ] 添加操作确认对话框
  - [ ] 实现加载状态和进度指示
  - [ ] 添加操作成功的反馈提示

- [ ] **7.3 国际化与主题**
  - [ ] 配置Vue I18n国际化支持
  - [ ] 实现中英文语言切换
  - [ ] 完善暗色主题支持
  - [ ] 实现主题的动态切换
  - [ ] 优化不同主题下的视觉效果

### 阶段八：测试与部署准备 🚀
> **目标**：完善测试覆盖，准备生产部署，确保应用质量
> **预期效果**：应用通过完整测试，具备生产部署条件

- [ ] **8.1 测试完善**
  - [ ] 编写核心组件的单元测试
  - [ ] 编写API集成测试
  - [ ] 编写用户交互的E2E测试
  - [ ] 测试不同浏览器的兼容性
  - [ ] 测试响应式布局的适配效果


## 开发原则

### 技术原则
- **渐进式开发**：每个阶段都有可运行的成果，便于测试和验证
- **组件化设计**：高内聚低耦合，便于维护和扩展
- **性能优先**：关注用户体验，优化加载和渲染性能
- **错误优雅**：完善的错误处理和用户反馈机制

### 质量原则
- **代码质量**：清晰的代码结构和注释说明
- **测试驱动**：重要功能必须有测试覆盖
- **文档完善**：清晰的API文档和使用说明
- **版本控制**：合理的Git提交和分支管理

## 当前状态
- ✅ **阶段一完成**：基础框架搭建与技术验证已完成
- ✅ **阶段二完成**：Mind-elixir集成和数据转换系统已实现
- ✅ **阶段三完成**：状态管理与工程管理已全部实现
- ✅ **架构重构完成**：API分层架构优化，职责清晰分离
- 🎯 **当前运行状态**：Vue 3应用已成功运行在 http://localhost:8080
- 📋 **已实现功能**：
  - 三栏响应式布局（工程管理、研究树可视化、消息对话） ✅
  - 完整的状态管理系统（Pinia stores） ✅
  - **重构后的API服务层**：纯HTTP客户端+Store业务逻辑 ✅
  - 基础UI组件框架 ✅
  - 国际化支持（中英文切换） ✅
  - 主题切换（亮色/暗色） ✅
  - **Mind-elixir思维导图集成** ✅
  - **数据转换系统**：后端快照→Mind-elixir格式 ✅
  - **真实后端数据获取**：使用真实snapshot_id ✅
  - **只读模式研究树可视化** ✅
  - **快照查看与回到当前**：消息→查看历史快照，支持UI提示与返回当前 ✅
  - **画布约束优化**：修正map-canvas无限扩展问题，受中间面板尺寸约束 ✅
  - **样式隔离和主题配置** ✅
  - **响应式布局优化**：确保不超出屏幕边界 ✅
  - **分层样式控制系统**：基于Mind-elixir原生属性 ✅
  - **完整的工程管理功能**：创建、保存、加载、删除、另存为 ✅
  - **工程状态管理**：projectStore完整实现 ✅
  - **工程管理UI组件**：ProjectManager和AppHeader完整实现 ✅
  - **消息系统UI优化**：消息默认收起、思考过程单独折叠、Markdown渲染与换行修复 ✅
- 🎯 **下一步**：实现研究树的交互式编辑功能模块（在只读可视化基础上，恢复/重建受约束的编辑交互，前后端同步计算）

## Cursor要求
- 开发过程中发现任何问题，例如原始设计有缺陷、遇到不能判断的选择、遇到难以解决的困难等，必须停下来向用户询问，甚至是多次对话询问，直到得到用户准确的答复之后再继续。
- 开发过程中完成规定任务后，必须更新本文档，勾掉已经完成的部分
- 如果在开发过程中修改了原始设计，必须向用户询问说明，得到肯定答复后必须更新前端总体需求和架构设计.md文档以及本文档，使设计时刻与具体实施保持一致。
- 前端已经启动，保持无头模式运行，日志记录在frontend/vue.log。
- 对于mind-elixir，其所有的功能说明必须严格参考文档`frontend/mind-elixir介绍文档.md`和官方插件项目`tests/node-menu（mind-elixir的插件，用于参考）`，必要时也可以参考我的老项目中的相关组件`tests/frontend（老）/src/App/MindTree.vue`。你必须仔细阅读这些信息，遇到问题时也必须反复查看这些信息，纠正自己的错误认识。
- 前端的大部分功能（除了研究树的交互式编辑）基本都在测试用命令行前端`test_CLI_frontend.py`中实现过了，你必须认真阅读和参考这个文件中的实现，这对你理解前后端配合方式有重大意义。

## Mind-elixir集成经验教训 🎓

### 关键问题与解决方案

#### 1. 版本兼容性问题 ⚠️
**问题**：Mind-elixir 5.0.6版本与老项目的4.5.2版本存在破坏性变更
- **现象**：5.x版本显示巨大操作按钮，样式崩坏，API变更
- **根本原因**：Mind-elixir在5.x版本中默认启用了更多UI元素和不同的样式系统
- **解决方案**：降级到与老项目一致的4.5.2版本
- **教训**：✅ **第三方库版本必须与参考项目保持一致**

#### 2. 样式隔离问题 🎨
**问题**：项目全局CSS污染Mind-elixir原生样式
- **现象**：节点布局混乱，连接线异常，整体风格不协调
- **根本原因**：Vue项目的全局CSS规则覆盖了Mind-elixir的默认样式
- **解决方案**：
  ```vue
  <style scoped> /* 使用scoped样式隔离 */
  :deep(.mind-elixir) { /* 使用深度选择器精确控制 */
    background-color: #ffffff !important;
  }
  </style>
  ```
- **教训**：✅ **第三方UI库需要样式隔离，优先使用scoped + 深度选择器**

#### 3. 数据初始化问题 📊
**问题**：Mind-elixir初始化参数传递错误
- **现象**：`Cannot read properties of undefined (reading 'deselect')`
- **根本原因**：传入`mind.init(data.nodeData)`而不是`mind.init(data)`
- **解决方案**：参考老项目，传入完整的数据对象
- **教训**：✅ **严格按照参考项目的API调用方式，不要自己推测**

#### 4. 主题配置问题 🌈
**问题**：Mind-elixir默认使用黑色背景主题
- **现象**：思维导图背景为黑色，与项目亮色主题不符
- **解决方案**：
  ```javascript
  const config = {
    theme: {
      name: 'Default',
      cssVar: {
        '--main-bgcolor': '#ffffff',
        '--color': '#303133'
      }
    }
  }
  ```
- **教训**：✅ **第三方库的主题需要显式配置，不能依赖默认值**

#### 5. 响应式布局问题 📱
**问题**：移动端CSS规则导致panel-header高度被压缩
- **现象**：`panel-header`高度从60px变成22.5px
- **根本原因**：媒体查询中的`height: 33.33%`限制
- **解决方案**：
  ```css
  .panel-header {
    min-height: 60px !important;
    flex-shrink: 0; /* 防止被压缩 */
  }
  ```
- **教训**：✅ **关键UI元素需要防压缩保护，使用flex-shrink: 0**

#### 6. API架构混合问题 🏗️
**问题**：apiService.js同时包含基础HTTP方法和高级业务逻辑
- **现象**：职责不清晰，Store和组件直接调用不同层次的API方法
- **根本原因**：未严格遵循分层架构原则，API服务层职责混合
- **解决方案**：
  ```javascript
  // ❌ 错误：混合架构
  apiService.get() + apiService.getCurrentSnapshot()
  
  // ✅ 正确：分层架构  
  Component → Store → apiService.get() → Backend
  ```
- **教训**：✅ **严格遵循分层架构，apiService只做HTTP客户端，业务逻辑在Store**

#### 7. 画布尺寸溢出问题 📏
**问题**：思维导图画布超出屏幕边界，出现滚动条
- **现象**：Mind-elixir容器高度超过视口，用户体验差
- **根本原因**：未正确计算可用高度，忽略了AppHeader和panel-header占用的空间
- **解决方案**：
  ```css
  /* 正确的高度计算 */
  .research-tree {
    height: 100%; /* 适应父容器，而非100vh */
    max-height: 100%;
    overflow: hidden;
  }
  .tree-container {
    flex: 1;
    max-height: 100%;
  }
  ```
- **教训**：✅ **复杂布局要准确计算可用空间，使用相对高度而非绝对视口高度**

#### 8. 真实数据获取问题 🔗
**问题**：使用假的snapshot_id测试，无法获取真实后端数据
- **现象**：测试使用硬编码ID，实际运行时获取不到数据
- **根本原因**：未理解后端API的正确调用流程，缺少获取当前快照ID的步骤
- **解决方案**：
  ```javascript
  // 正确的调用流程
  1. 获取当前工程数据 → current_snapshot_id
  2. 使用真实snapshot_id获取快照数据
  3. 转换数据格式用于前端显示
  ```
- **教训**：✅ **API调用要遵循正确的业务流程，优先参考CLI前端的实现**

### 最佳实践总结

#### ✅ 第三方库集成检查清单
1. **版本对齐**：确保与参考项目版本完全一致
2. **样式隔离**：使用scoped样式 + 深度选择器
3. **API对照**：严格按照参考项目的调用方式
4. **主题配置**：显式设置主题，不依赖默认值
5. **布局保护**：关键UI元素防压缩设置

#### ✅ 架构设计检查清单
1. **分层架构**：严格按照 Component → Store → ApiService → Backend 的调用链
2. **职责单一**：每个层次只负责自己的职责，不跨层调用
3. **数据流向**：组件通过Store获取数据，Store调用API服务
4. **业务逻辑**：集中在Store中，API服务只做HTTP通信
5. **API封装**：理解封装层的返回值结构，不要基于假设编程

#### ✅ 布局设计检查清单
1. **高度计算**：准确计算可用空间，考虑所有固定高度元素
2. **相对尺寸**：优先使用相对高度（100%）而非绝对视口高度（100vh）
3. **溢出控制**：设置 max-height 和 overflow: hidden 防止内容溢出
4. **响应式设计**：移动端单独处理，确保在所有设备上正常显示
5. **嵌套布局**：理解父子容器的高度传递关系

#### ✅ 数据获取检查清单
1. **API流程**：遵循正确的业务流程，参考CLI前端实现
2. **真实数据**：使用真实的ID而非硬编码测试数据
3. **错误处理**：优雅处理无数据、网络错误等异常情况
4. **数据转换**：确保后端数据正确转换为前端所需格式
5. **状态管理**：正确更新Store状态，触发UI响应

#### ✅ 调试策略
1. **对比分析**：出现问题时对比老项目的实现
2. **渐进调试**：从最简配置开始，逐步增加功能
3. **版本回退**：遇到兼容性问题优先考虑版本对齐
4. **样式检查**：使用浏览器开发工具检查CSS冲突
5. **日志分析**：添加详细的调试日志定位问题
6. **架构检查**：确认是否遵循正确的分层架构

#### ✅ 代码质量要求
1. **参考为准**：严格参考老项目的成功实现
2. **架构一致**：确保新增代码符合项目架构原则
3. **渐进开发**：先实现基础功能，再添加高级特性
4. **错误处理**：完善的错误捕获和用户反馈
5. **文档更新**：及时记录问题和解决方案

---
