重构projectStore、treeStore和messageStore，遵循以下原则：

存储器有三类常见接口，分别为同步（actions类，从后端同步数据）、获取（getters类，读出数据）、写入（actions类，向后端写入数据并重新同步），除此之外可选有仅内部使用的工具方法（actions），确保代码的复用性和可读性。其中同步严格限制为内部接口，即只在store程序内部控制什么时候需要更新（惰性加载，如果发现没有数据则自动更新。getters函数是同步的，所以需要更新时启动异步的同步数据方法，启动后直接返回空值即可），禁止在外部调用；每次写入数据后必须从后端同步数据，不能私自在前端直接更新数据；必须使用getters中的接口读取数据，不能直接读取数据。

注：isLoading和error属性，setLoading、setError、clearError为所有store均有的基础成员，isLoading用于表示当前存储器是否有同步工作正在进行，所有同步函数开始时先要判断是否有同步工作正在进行，如果有的话直接返回不再重复同步。下方将不再赘述其定义和调用时机，但所有存储器都要实现它们。
**修改后，三个数据存储只有messageStore引用treeStore，无其它引用关系**
服务文件改为存储的下级，即由存储文件负责调用服务程序，后者不再由组件直接调用
所有存储数据初始化为null，null代表未与后端同步，而其它的空值，如{}、[]等则代表同步了但返回为空。


## projectStore
**存储内容**：
1. currentProject（/projects/current/info接口数据，name、created_at、updated_at三个字段）
2. projectList（数组类型，/projects接口数据）
- 注意：删除掉lastSaveTime属性，因为该属性可以从currentProject的updated_at获得。如果updated_at为“”或null等非法情况（刚创建的工程是不会自动保存的），则应显示“未保存”

**同步**：
1. 同步整个存储
	1. /projects获取工程列表，更新projectList。projectList为null代表尚未同步
	2. /projects/current/info获取当前工程信息，更新currentProject。currentProject为null代表尚未同步

**获取**：
1. getCurrentProject（返回当前工程对象；若本地无数据则自动触发同步，立即返回null）
2. getProjectList（返回工程列表；若本地无数据（为null）则自动触发同步，立即返回null）
3. getIsProjectNameExists(name)（检查工程名称是否已存在，用于表单校验）
4. getLastSaveTime（返回currentProject.updated_at；若为空值则视为“未保存”）
5. getIsLoading（返回加载状态，仅用于按钮禁用等UI逻辑）

**写入**：
1. createProject（调用/projects?project_name=接口，之后同步projectStore）
2. loadProject（调用/projects/接口，直接更新currentProject，无需全部同步）
3. saveProject（调用/projects/save接口，直接更新currentProject的updated_at，无需全部同步）
4. saveAsProject（调用/projects/save-as?new_project_name=接口，之后同步projectStore）
5. deleteProject（调用delete /projects/接口，之后同步projectStore）


## treeStore
**存储内容**：
1. currentSnapshot（当前快照数据，结构与后端一致）
2. tempSnapshotData
	- 不再使用isViewingSnapshot和tempSnapshotId，用tempSnapshotData是否为空来表示是否是展示临时快照状态；tempSnapshotData本身包含id属性
3. agentOperatingNodeId（智能体正在操作的节点ID，如果为空值代表智能体不在执行，如果为"-"代表当前正在传输系统消息）
4. mindElixirData（渲染缓存，可置空）

**工具方法**：
按需自行复用，确保代码可读性和复用性

**同步**：
1. 同步当前快照（currentSnapshot为null时代表尚未同步）
	1. 调用/research-tree/snapshots/current-id获取current_snapshot_id
	2. 调用/research-tree/snapshots/{snapshot_id}获取真实快照，更新currentSnapshot
	3. 同步临时快照（传入空值）
	4. agentOperatingNodeId设置为空值
2. 同步临时快照（查看快照），传入快照id（可空）（tempSnapshotData为null时代表尚未同步）
	1. 如果id为空，设置tempSnapshotData为{}
	2. 如果id不为空
		1. 调用/research-tree/snapshots/{snapshot_id}获取快照，更新tempSnapshotData
		2. 调用ResearchTreeTransformer，用tempSnapshotData生成mindElixirData

**获取**：
1. getDisplaySnapshotData（如果mindElixirData不为null直接返回，否则触发同步当前快照并返回null）
2. getCurrentSnapshot（返回currentSnapshot；若为null则触发同步当前快照并返回null）
3. getIsViewingSnapshot（返回tempSnapshotData是否不为空值，如果tempSnapshotData为null则触发同步临时快照并返回null）
4. getAgentOperatingNodeId（返回智能体操作中的节点ID）
5. getCurrentAgentName（将智能体操作中的问题节点（如果id是方案节点，则找到其父问题节点）标题组装为智能体名称（如『xx』的负责专家），如果agentOperatingNodeId为“-”，则返回“系统消息”）
6. getAllSolutionTitles获取当前研究树中所有解决方案节点的标题
7. getAllImplementaionProblemTitles获取当前研究树所有实施问题节点的标题
8. getNodeIdByTitle根据标题得到节点id

**写入**：
1. viewSnapshot(snapshotId)（调用同步临时快照，传入snapshotId）
2. exitSnapshotView（退出查看态，调用同步临时快照，传入空值）
3. setSelectedNode(nodeId)（设置选中节点）
4. setAgentOperatingNode(nodeId)（设置智能体操作节点）
5. updateCurrentSnapshot(snapshotData)（接收SSE快照更新并覆盖currentSnapshot，并且调用ResearchTreeTransformer，更新mindElixirData）

## messageStore
**存储内容**：
1. messages（消息列表）
2. isGenerating（是否正在生成）
3. sseConnection、currentGeneratingMessageId（SSE连接与生成中消息ID）

**工具方法**：
1. 将后端消息转为前端消息
2. handleSSEStream
3. handlePatch及其它handleSSEStream中调用的工具方法
4. 按需自行复用出其它工具方法

**同步**：
1. 同步消息历史（内部）
	1. GET /projects/current/full-data，读取messages与incomplete_message_id
	2. 转换为前端消息结构并覆盖messages
	3. 若存在incomplete_message_id则自动调用续传接口建立SSE
2. 同步触发时机（内部）
	1. 首次访问getMessageList/getMessageCount且本地无数据
	2. 工程切换完成后
	3. 发送/回溯/停止等写入动作完成后

**获取**：
1. getMessageList（返回消息数组；若本地无数据（为null的时候）则自动触发同步，立即返回null）
2. getMessageCount（返回消息数量）
3. getIncompleteMessage（获取状态为generating的消息）
4. getIsGenerating（是否正在生成）
5. getIsLoading（加载状态）
6. getError（错误信息）

**写入**：
1. 发送消息，开始流式传输
2. 中断流式传输


流式传输处理逻辑（参考test_CLI_frontend.py）
1. event.event="patch"
	1. patch_data = event.data
	2. 用patch_data的role和publisher字段判断当前是否为智能体操作，以及智能体在操作的节点id，调用treeStore的setAgentOperatingNode(nodeId)。如果role不是assistant，或者role是assistant但publisher_id为空，则传入NodeId为“-”，treeStore自动判定为系统消息
	3. 如果patch_data的snapshot字段不为空，调用treeStore的updateCurrentSnapshot，更新当前快照
	4. 如果patch_data的rollback字段不为空且为true，执行回溯操作_handle_rollback
	5. 如果不包含rollback字段或为false
		1. 如果message_id存在且为"-"，执行_update_all_messages
		2. 否则
			1. 如果message_id已经在messages中，执行_create_message_from_patch
			2. 否则_update_existing_message
2. event.event="error"
	1. 结束sse传输，并弹窗报错
3. event.event="finished"
	1. 结束sse传输
注意：messageStore中与SSE接收相关的逻辑必须严格参考test_CLI_frontend中的handle_sse_stream和handle_patch以及其它相关辅助函数。