现在要实现研究树的交互式编辑功能。

## 交互限制
1. 除了根问题以外，其它的问题不能单独编辑，而是要通过编辑上级解决方案的方式来编辑。
2. 编辑解决方案有两种方式
	1. 一种是如果所有子问题的顺序没用被变动过，且任何子问题都没有编辑再保存过，则可以使用Patch /research-tree/solutions/{solution_id}接口，只更新除子问题以外的其它内容。此时传入接口的负载不能包含子问题列表。
	2. 如果有任何子问题被编辑过，或者子问题的顺序被改变过，则需要使用/research-tree/problems/{problem_id}/solutions重新创建一个解决方案
		- 被编辑过的子问题的id要赋值为null
		- 传入此接口时，需要把修改后的所有子问题组装到负载的子问题列表传入，其中id为null的子问题代表新建的子问题，不为null的代表要从原解决方案中继承的子问题，即没被修改过的。
	- 在编辑时，需要提示用户当前编辑的状态是编辑状态还是新建解决方案状态
3. 因为第2条的约束，所以创建解决方案时必须要把所有内容以及所有子问题的所有内容全部写好，一并提交，而不能分部分写完更新。
4. 解决方案的子问题的顺序有约束，必须先条件问题，后实施问题。因此在编辑和展示时，条件问题和实施问题应该分开放在两个区域内，从而强制约束。
5. 任何对研究树的编辑请求，应通过messageStore的发送修改请求接口实现，所有这些接口中，在调用后端接口后，必须刷新messageStore和treeStore的数据。即从后端同步新数据，而不是在前端直接修改。

## 请求接口及数据模型

具体请查看`backend/routers/research_tree.py`中的代码

| 接口 | 方法 | 路径 | 功能描述 |
|------|------|------|----------|
| 创建根问题 | POST | `/research-tree/problems/root` | 创建新的根级研究问题 |
| 更新根问题 | PATCH | `/research-tree/problems/root/{problem_id}` | 更新根问题的标题、意义、标准等 |
| 删除根问题 | DELETE | `/research-tree/problems/root/{problem_id}` | 删除指定的根问题 |
| 创建解决方案 | POST | `/research-tree/problems/{problem_id}/solutions` | 为问题创建解决方案 |
| 更新解决方案 | PATCH | `/research-tree/solutions/{solution_id}` | 更新解决方案内容 |
| 删除解决方案 | DELETE | `/research-tree/solutions/{solution_id}` | 删除解决方案及其子树 |
| 设置选中方案 | POST | `/research-tree/problems/{problem_id}/selected-solution` | 设置问题的当前选中解决方案 |

class ProblemRequest(BaseModel):
    id: Optional[str] = None
    title: str
    significance: str
    criteria: str
    problem_type: ProblemType = ProblemType.IMPLEMENTATION

class SolutionRequest(BaseModel):
    title: str
    top_level_thoughts: Optional[str] = None
    implementation_plan: Optional[str] = None
    plan_justification: Optional[str] = None
    state: Optional[SolutionState] = SolutionState.IN_PROGRESS
    final_report: Optional[str] = None # 暂时用不到，忽略即可
    children: Optional[List[ProblemRequest]] = None


class SetSelectedSolutionRequest(BaseModel):
    solution_id: Optional[str] = None

## 设计思路

### 解决方案面板组件

重点完成解决方案面板组件的设计。

#### 整体布局：
整个面板充满研究树展示区域，上下左右均留出20px的空隙。
上方有一个窄横条状的头部
余下的矩形区域横向分为四列，从左至右依次为：顶层思路、研究计划（子问题列表）、收尾工作计划、可行性论证
研究计划中上下对半分成两个独立滚动的列表，分别为条件问题列表和实施问题列表
整体尽可能简洁，节约空间用于展示或编辑内容文本，而样式风格要尽可能与整个前端样式相契合。

子问题列表中所有的问题节点用问题节点组件展示。

#### 业务逻辑：
标题(title)文本、(state)状态
- 展示模式下
	- 头部显示标题(title)文本、当前方案的状态(state)、当前方案是否被上级问题选中的开关（启用该开关，允许选中或不选中，切换时调用messageStore的相应接口，设置父节点的选中方案id。如果当前解决方案节点id不为空（不是新建模式），且子问题未改变，则调用修改解决方案接口，否则调用新建解决方案接口）、编辑按钮（切换到编辑模式）、关闭按钮
		- state的显示如下：
			- success显示为已成功
			- failure显示为已失败
			- in_progress显示为进行中
		- 编辑按钮当且仅当当前无智能体正在工作，同时也非查看快照状态时才能启用，否则禁用
	- 顶层思路、收尾工作计划、可行性论证三个部分依次用MarkdownRenderer清楚的展示解决方案节点的top_level_thoughts、implementation_plan、plan_justification三个长markdown字符串
	- 子问题列表中每个子问题元素，被限制在不能编辑模式下。
- 编辑模式下
	- 头部标题显示为文本输入框，状态被设置为”in_progress“，是否选中开关（禁用切换功能），保存按钮（在messageStore中调用相应接口，回到展示状态）、取消按钮（将所有数据撤回到修改前的状态（需要保留修改前的数据），并退回展示状态）、编辑状态显示（一个绿色的"编辑中"或者橙色的"新建中"，用以表征当前子问题列表是否被修改过，是否需要新建方案）
	- 顶层思路、收尾工作计划、可行性论证三个部分均用文本输入框展示以便编辑。
	- 子问题列表中的问题进入可编辑状态下
	- 子问题列表中条件问题列表和实施问题列表分别显示出一个添加问题按钮，点击后自动在列表的最底下添加一个空问题，标题设置为未命名，其它设置为""。

### 问题元素组件

#### 整体布局
类似于MessageItem组件，只是只有标题栏可以折叠，折叠区域中自上而下为重要性和评判标准。两个区域均有高度限制，超过高度限制自动滚动。

#### 业务逻辑
1. 展开与折叠状态
	- 折叠状态下，显示问题的标题，以及展开按钮，不显示折叠区域
	- 展开状态下，打开折叠区域，显示出重要性(significance)和评判标准(criteria)两段文本
2. 可编辑与不可编辑状态
	- 可编辑状态下
		- 未编辑状态：标题的右侧显示用icon按钮显示编辑按钮（切换至编辑状态）、向上移动按钮、向下移动按钮。重要性和评判标准用MarkdownRenderer显示
		- 编辑状态：标题右侧用icon按钮显示保存和取消按钮。标题、重要性和评判标准均用可编辑文本框显示。
	- 不可编辑状态下
		- 不显示编辑、上移、下移按钮，其它与未编辑状态一致。
3. 其余显示：一个绿色或橙色的小点，绿色代表当前id不为空，说明未编辑过，橙色代表id为空，说明已经编辑又保存过了。
需要展示title以及重要性(significance)、评判标准(criteria)两个短文本。


### 根研究问题面板
整体布局和业务逻辑与现在的解决方案面板相近
只是不需要显示和编辑子研究问题
只给出两个大列，分别呈现根问题的重要性和评判标准即可。

### 响应式设计：
数据的获取应该是响应式的，即在ResearchTree中通过响应式方式从treeStore中加载，并且直接传入该组件。当treeStore被更新时，面板也应该相应更新（如果该id对应的节点还存在的话，否则面板自动关闭）

### 交互体验设计
1. 用户点击某一解决方案节点时，用该方案节点的内容弹出解决方案面板，初始为查展示模式
2. 用户点击某一实施问题节点时，弹出解决方案面板，内容均为空，初始为编辑模式，代表创建解决方案
3. 用户点击某一条件问题节点时，不弹出解决方案面板
4. 新：用户点击整个mind-elixir的根节点时（id为mind-root），弹出根研究问题面板，处于创建状态
5. 新：用户点击某个根研究问题时，弹出一个对话框，允许用户选择
	1. 在该问题下新建解决方案
	2. 查看该根研究问题
	3. 取消

### 组件关系规范
1. 解决方案面板的数据独立，与父组件间的接口关系仅为传入的当前选择节点Id。同时父组件负责根据节点id是否为null控制方案面板的v-if。即每次取消选择后方案面板都被销毁。
方案面板的所有数据应直接从treeStore中获得（需要在treeStore中定制相应的getters接口，例如判断一个节点id是解决方案还是实施问题还是条件问题，获取一个实施方案节点的面板数据等），所有操作应通过调用messageStore的接口实现。
2. 问题元素的数据和接口需要由解决方案面板提供，由后者管理和实现，不能直接操作存储器，更不能直接操作网络接口。

问题元素组件不能操作存储器指的是该组件中不应该存在以下两行代码：
import { useMessageStore } from '@/stores/messageStore'
import { useTreeStore } from '@/stores/treeStore'



添加一个子问题展示面板组件，用于展示一个非根问题节点的问题的详细信息，其内容和排版与根问题面板的展示模式相近，但不支持编辑功能。
用户在点击一个实施问题节点时，需要改为像点击根问题节点一样弹出新建解决方案还是查看问题的对话框，并弹出相应的面板。
当点击一个条件问题节点时，直接打开问题展示面板


添加功能：在展示状态的解决方案面板和子问题展示面板两个面板的最底下，添加一个横向的长条输入框，用于用户在查看方案或方案中的节点时，与相应的负责智能体展开对话。
具体而言，如果是方案面板，则取当前方案节点的id为solution_id，否则如果是子问题面板，则取当前节点的父解决方案节点id为solution_id。对话应该用以下方式调用messageStore的发送消息接口，向当前的解决方案节点，或当前子问题节点的父方案节点发送消息。
await messageStore.sendMessage(content, title="用户消息", agentName="user_chat_agent", otherParams = { solution_id: solution_id })
如果当前为子问题节点，则content应自动添加一个前缀：`对于你方案中的子问题「${parentProblem.title}」:\n`，这个前缀也应该在消息输入框中时刻展示，并且不能被用户编辑。

消息框的占位符应该为：`向${treeStore.getAgentNameByNodeId(solution_id)}发送消息`
消息框的风格应该与MessageCenter.vue中的input-area类似。

发送消息之后，应自动关闭当前面板